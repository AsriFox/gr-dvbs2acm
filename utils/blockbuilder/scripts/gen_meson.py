# Generate meson.build files for the entire block library

from jinja2 import Template, FileSystemLoader, DictLoader, Environment
import os
import yaml
import argparse
import shutil
import glob
import filters

def argParse():
    """Parses commandline args."""
    desc='Generates meson.build for each block'
    parser = argparse.ArgumentParser(description=desc)
    
    parser.add_argument("blocklib_path")
    parser.add_argument("--clear", action='store_true')
    parser.add_argument("--enable_python", action='store_true')
    parser.add_argument("--enable_purelib", action='store_true')

    return parser.parse_args()


def gen_meson_block(args, env, root):
    # Look for blocklib/{modulename}/{blockname}/{blockname}.yml
    yml_files = glob.glob(os.path.join(root,'*.yml'))
    if not yml_files:
        return
    
    # root == {blockname}
    # Generate {blockname}/meson.build or remove it (--clear)
    existing_meson_filename = os.path.join(root, 'meson.build')
    if (os.path.exists(existing_meson_filename)):
        with open(existing_meson_filename, 'r') as meson_file:
            if not meson_file.readline().startswith('#autogenerated'):
                # Meson file is not autogenerated, skipping
                return
        if args.clear:
            os.remove(existing_meson_filename)
            print(f'removing: {root}/{existing_meson_filename}')
    if args.clear:
        return

    # Meson file is autogenerated, overwriting
    with open(yml_files[0]) as file:
        d = yaml.load(file, Loader=yaml.FullLoader)
        d['GR_ENABLE_PYTHON'] = args.enable_python
        d['GR_PURELIB'] = args.enable_purelib
        new_meson_filename = os.path.join(os.path.dirname(yml_files[0]), 'meson.build')
        template = env.get_template('blockname.meson.build.j2')
        cufiles = [os.path.basename(x) for x in glob.glob(os.path.join(root, '*.cu'))]
        rendered = template.render(d, cufiles=cufiles)
        with open(new_meson_filename, 'w') as file:
            print(f'generating: {root}/{new_meson_filename}')
            file.write(rendered)
        # Generate meson.build for Python blocks
        # if 'implementations' in d:
        #     for impl in d['implementations']:
        #         if 'lang' in impl and impl['lang'] == 'python':
        #             template = env.get_template('blockname_python_impl_meson.build.j2')
        #             tmp = d
        #             tmp['impl'] = impl
        #             rendered = template.render(tmp)
        #             meson_filename = os.path.join(root, impl['id'], 'meson.build')
        #             with open(meson_filename, 'w') as file:
        #                 print('generating ' + meson_filename)
        #                 file.write(rendered)


def gen_meson_module(args, env, current_module_path, module_name):
    # Generate {modulename}/meson.build or remove it (--clear)
    meson_filename = os.path.join(current_module_path, 'meson.build')
    if os.path.exists(meson_filename):
        with open(meson_filename, 'r') as meson_file:
            if not meson_file.readline().startswith('#autogenerated'):
                # Meson file is not autogenerated, skipping
                return
        if args.clear:
            os.remove(meson_filename)
            print(f'removing: {meson_filename}')
    if args.clear:
        pybind_meson_filename = os.path.join(current_module_path, 'python', module_name, 'meson.build')
        if (os.path.exists(pybind_meson_filename)):
            os.remove(pybind_meson_filename)
            print(f'removing: {pybind_meson_filename}')
        return

    # Meson file is autogenerated, overwriting
    blockdirs = []
    for y in os.listdir(current_module_path):
        # List all block directories - they have {blockname}.yml inside:
        current_block_path = os.path.join(current_module_path, y)
        if (
            y not in ['lib', 'include', 'test', 'bench', 'python', 'examples']
            and os.path.isdir(current_block_path)
            and os.path.exists(os.path.join(current_block_path, os.path.basename(current_block_path) + '.yml'))
        ):
            print('   ' + y)
            blockdirs.append(os.path.basename(y))

    # Generate {modulename}/meson.build
    print(os.path.join(current_module_path, 'enums.yml'))
    has_enums = os.path.exists(os.path.join(current_module_path, 'enums.yml'))
    template = env.get_template('module.meson.build.j2')
    rendered = template.render(module=module_name, blocks=blockdirs, has_enums=has_enums)
    with open(meson_filename, 'w') as file:
        print(f'generating: {meson_filename}')
        file.write(rendered)

    # Generate {modulename}/include/gnuradio/{modulename}/api.h
    template = env.get_template('api.h.j2')
    rendered = template.render(module=module_name)
    api_filename = os.path.join(current_module_path, 'include', 'gnuradio', module_name, 'api.h')
    with open(api_filename, 'w') as file:
        print(f'generating: {api_filename}')
        file.write(rendered)


def gen_meson_module_pybind(args, env, module_name):
    current_module_path = os.path.join(args.blocklib_path, module_name)
    if not os.path.isdir(current_module_path):
        return

    # Generate {modulename}/python/gnuradio/{modulename}/meson.build or remove it (--clear)
    meson_filename = os.path.join(current_module_path, 'python', 'gnuradio', module_name, 'meson.build')
    if os.path.exists(meson_filename):
        with open(meson_filename, 'r') as meson_file:
            if not meson_file.readline().startswith('#autogenerated'):
                # Meson file is not autogenerated, skipping
                return
        if args.clear:
            os.remove(meson_filename)
            print(f'removing: {meson_filename}')
    if args.clear:
        return

    # Meson file is autogenerated, overwriting
    # Generating module.build for python bindings (?):
    template = env.get_template('module_python.meson.build.j2')
    rendered = template.render(module=module_name, GR_PURELIB=args.enable_purelib)
    with open(meson_filename, 'w') as file:
        print(f'generating: {meson_filename}')
        file.write(rendered)


def main():
    args = argParse()

    paths = []
    paths.append(os.path.join(os.path.dirname(os.path.realpath(__file__)),'..','templates'))
    env = Environment(loader = FileSystemLoader(paths))
    env.filters.update(filters.custom_filters())

    for root, d_names, f_names in os.walk(args.blocklib_path):
        gen_meson_block(args, env, root)

    modulesdirs = []
    for x in os.listdir(args.blocklib_path):
        # List all module directories:
        current_module_path = os.path.join(args.blocklib_path, x)
        if os.path.isdir(current_module_path):
            module_name = os.path.basename(x)
            print(module_name)
            modulesdirs.append(module_name)
            gen_meson_module(args, env, current_module_path, module_name)

    # for module_name in modulesdirs:
    #     gen_meson_module_pybind(args, env, module_name)


if __name__ == "__main__":
    main()
